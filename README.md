# kindling-java
Kindling-java is an attach agent to collect Java CPU / LOCK for probe which relies on [async-profiler](https://github.com/CloudDectective-Harmonycloud/async-profiler). Besides it also collect traceId generated by SkyWalking agent.

Features
* [Event] Collect datas by events specified by event argument[cpu / lock / traceid].
* [Plugins] Enhance SkyWalking Agent and print traceId and span into /dev/null.

## Build Kindling Java & AsyncProfiler
```
# Binary will be built in build/async-profiler-${version}-${arch}.${zip/tar.gz}
$ ./build.sh

async-profiler-2.8.3-linux-x64
├── agent
│   ├── 1.0.1
│   │   ├── agent-core.jar
│   │   ├── plugin-traceid-sw.jar
│   │   └── plugin-span-sw.jar
│   ├── agent-boot.jar
│   └── version
├── build
│   ├── async-profiler.jar
│   ├── converter.jar
│   ├── fdtransfer
│   ├── jattach
│   └── libasyncProfiler.so
├── CHANGELOG.md
├── LICENSE
├── profiler.sh
└── README.md
```

We also support build in container using following command.
```
$ ./build.sh linux-${arch}
X64:        ./build.sh linux-x64
X64-MUSL    ./build.sh linux-x64-musl
ARM64       ./build.sh linux-arm64
```

## Attach Java Application
> ./profiler.sh start $options $pid

Options:
* -e  EvnetTypes cpu / lock / traceid, all is opened by default.
* -i  Collect CPU interval(nanosecond), default is 10000000.
* -j  Collect CPU stack max-depth, default is 20.

Eg.
```
# Collect CPU with max-depth 10.
> ./profiler.sh start -e cpu -j 10 $pid

# Open CPU & LOCK
> ./profiler.sh start -e cpu -e lock $pid
```

## Detach Java Application
> ./profiler.sh stop $pid

## How it works
* Jattach copy the agent and libasyncprofiler.so into container.
* Jattach attach agent into application.
* Agent start asyncProfiler by call asyncProfielr API.
    * Load libasyncprofiler.so
    * Execute start/stop command
    * Execute print to collect CPU data at fixed rate
* Agent enhance Skywalking agent by asm and print traceid into /dev/null.
    * Begin / End life cycle of the trace
    * When trace is dispatched into another thread, begin / end life cycle of the runnable execution.